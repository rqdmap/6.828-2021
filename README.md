## [6.S081 2021 Fall](https://pdos.csail.mit.edu/6.828/2021/schedule.html)

[toc]

### Lab: Xv6 and Unix utilities

几个简单系统调用的使用。

代码行数: 210
耗时: 5h

### Lab: system calls

实现一个系统调用；阅读syscall.c的相关代码，对系统调用的发生和处理有一个基本的了解。

代码行数: 131
耗时: 3h

### Lab: page tables

实现关于页表的几个简单功能，掌握三级页表的结构，学会映射若干物理页到进程页表中。

代码行数: 81
耗时: 5h

### Lab: traps

实现backtrace功能，通过栈帧中的地址内容不断回溯获取调用信息。

实现alarm功能，通过sigalarm和sigreturn的配合完成trapframe帧的存储、恢复，通过修改trapframe帧中的pc寄存器内容完成向中断处理函数的跳转。

代码行数: 91
耗时: 8h

### Lab: Copy-on-Write Fork for xv6

实现cow功能，涉及到对页表中pte标志位的操作、物理内存分配和回收、以及中断处理的相关内容。

代码行数: 160
耗时: 15h

### Lab: Multithreading

在用户态下实现一个进程切换的功能，需要结合汇编代码对寄存器上下文进行存储和恢复。

学习自旋锁和条件变量在多线程控制中的相关应用。

代码行数: 89
耗时: ?

### Lab: networking

编写网络驱动程序，需要大概看一些关键的手册内容，写的很烂甚至可能是错的但是通过了测试=.=

~~对Linux设备驱动无感，暂时不想深究~~

代码行数: 72
耗时: 10h


### Lab: locks

内存分配器，为每个CPU分配一个lock，同时允许CPU自己内存不足时偷取其余CPU拥有的内存即可。

Buffer Cache，磁盘与内存之间的cache，使用LRU替换规则。基本思路是根据blockno分几个哈希桶，每个桶里面有锁和cache链。替换的时候是遍历所有的桶，根据ticks检查最久远未被使用的cache块进行替换，但是有BUG调不出来。学习了他人的思路，发现别人的假算法可过：只从当前blockno所在的桶开始往后找第一个没有引用的块，并且不检查自身所在的桶....事实上因为初始化时所有的空块全部放在了0号桶中，因而只要第一次进行bget的时候没有恰好映射到0号桶，就不会发生错误，但是该方法还是会被精心hack掉，而且效率感觉上不会很令人满意？不过最后结果能过，就先这样...

代码行数: 130
耗时: 10h

### Lab: file system

大文件系统，更改inode的寻址方式，增加两级寻址即可。

符号链接，创建链接时需要新建一个链接文件，在对应的inode中设置类型为符号链接；open系统调用则判断类型后读取到链接的文件路径，并打开该真实文件。

代码行数: 98
耗时: 5h

### Lab: mmap (hard)

实现mmap映射。综合运用了页表、中断处理、文件读写、进程管理的相关知识。

代码行数: 300
耗时: 15h

## 总结

断断续续做完一整个Lab靠近一个月，总体上感觉这套课程对于操作系统整体的方面没有什么过多赘述，而是更加关注OS内部的具体实现细节。亲手完成页表管理、中断处理、mmap等各种小功能确实让人学习到很多，但是仍然有许多功夫在lab之外，因而本lab大概只能起到抛砖引玉的作用，继续学习~
